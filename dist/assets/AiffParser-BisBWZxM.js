import{m as e,b as t,U as a,F as s,a as i,S as n,c as o,B as r,E as m,d as h,o as c}from"./index-pBuBQYRc.js";import{I as l}from"./ID3v2Parser-DFchjb5K.js";const p={NONE:"not compressed\tPCM\tApple Computer",sowt:"PCM (byte swapped)",fl32:"32-bit floating point IEEE 32-bit float",fl64:"64-bit floating point IEEE 64-bit float\tApple Computer",alaw:"ALaw 2:1\t8-bit ITU-T G.711 A-law",ulaw:"µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer",ULAW:"CCITT G.711 u-law 8-bit ITU-T G.711 µ-law",ALAW:"CCITT G.711 A-law 8-bit ITU-T G.711 A-law",FL32:"Float 32\tIEEE 32-bit float "};class AiffContentError extends(e("AIFF")){}class Common{constructor(e,t){this.isAifc=t;const a=t?22:18;if(e.chunkSize<a)throw new AiffContentError(`COMMON CHUNK size should always be at least ${a}`);this.len=e.chunkSize}get(e,o){const r=t.get(e,o+8)-16398,m=t.get(e,o+8+2),h={numChannels:t.get(e,o),numSampleFrames:a.get(e,o+2),sampleSize:t.get(e,o+6),sampleRate:r<0?m>>Math.abs(r):m<<r};if(this.isAifc){if(h.compressionType=s.get(e,o+18),this.len>22){const t=i.get(e,o+22);if(t>0){if(23+t+(t+1)%2!==this.len)throw new AiffContentError("Illegal pstring length");h.compressionName=new n(t,"latin1").get(e,o+23)}else h.compressionName=void 0}}else h.compressionName="PCM";return h}}const u={len:8,get:(e,t)=>({chunkID:s.get(e,t),chunkSize:Number(BigInt(a.get(e,t+4)))})},d=o("music-metadata:parser:aiff");class AIFFParser extends r{constructor(){super(...arguments),this.isCompressed=null}async parse(){if("FORM"!==(await this.tokenizer.readToken(u)).chunkID)throw new AiffContentError("Invalid Chunk-ID, expected 'FORM'");const e=await this.tokenizer.readToken(s);switch(e){case"AIFF":this.metadata.setFormat("container",e),this.isCompressed=!1;break;case"AIFC":this.metadata.setFormat("container","AIFF-C"),this.isCompressed=!0;break;default:throw new AiffContentError(`Unsupported AIFF type: ${e}`)}this.metadata.setFormat("lossless",!this.isCompressed);try{for(;!this.tokenizer.fileInfo.size||this.tokenizer.fileInfo.size-this.tokenizer.position>=u.len;){d(`Reading AIFF chunk at offset=${this.tokenizer.position}`);const e=await this.tokenizer.readToken(u),t=2*Math.round(e.chunkSize/2),a=await this.readData(e);await this.tokenizer.ignore(t-a)}}catch(t){if(!(t instanceof m))throw t;d("End-of-stream")}}async readData(e){switch(e.chunkID){case"COMM":{if(null===this.isCompressed)throw new AiffContentError("Failed to parse AIFF.COMM chunk when compression type is unknown");const t=await this.tokenizer.readToken(new Common(e,this.isCompressed));return this.metadata.setFormat("bitsPerSample",t.sampleSize),this.metadata.setFormat("sampleRate",t.sampleRate),this.metadata.setFormat("numberOfChannels",t.numChannels),this.metadata.setFormat("numberOfSamples",t.numSampleFrames),this.metadata.setFormat("duration",t.numSampleFrames/t.sampleRate),(t.compressionName||t.compressionType)&&this.metadata.setFormat("codec",t.compressionName??p[t.compressionType]),e.chunkSize}case"ID3 ":{const t=await this.tokenizer.readToken(new h(e.chunkSize)),a=c(t);return await(new l).parse(this.metadata,a,this.options),e.chunkSize}case"SSND":return this.metadata.format.duration&&this.metadata.setFormat("bitrate",8*e.chunkSize/this.metadata.format.duration),0;case"NAME":case"AUTH":case"(c) ":case"ANNO":return this.readTextChunk(e);default:return d(`Ignore chunk id=${e.chunkID}, size=${e.chunkSize}`),0}}async readTextChunk(e){const t=(await this.tokenizer.readToken(new n(e.chunkSize,"ascii"))).split("\0").map((e=>e.trim())).filter((e=>e?.length));return await Promise.all(t.map((t=>this.metadata.addTag("AIFF",e.chunkID,t)))),e.chunkSize}}export{AIFFParser};
